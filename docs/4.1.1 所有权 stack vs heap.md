[TOC]

## 所有权
所有权是 Rust 最独特的特性，它让 Rust 无需 GC 就可以保证内存安全。


## 什么是所有权
- Rust 的核心特性就是所有权;
- 所有程序在运行时都必须管理它们使用计算机内存的方式;
  - 有些语言有垃圾收集机制，在程序运行时，它们会不断地寻找不再使用的内存;
  - 在其他语言中，程序员必须显式地分配和释放内存;
- Rust 采用了第三种方式：
  - 内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时检查的规则;
  - 当程序运行时，所有权特性不会减慢程序的运行速度;


## 范围
- Rust的所有权规则主要涉及堆数据，但它们也影响栈数据的使用方式。在Rust中，所有数据都存在于栈（stack）或堆（heap）上，但所有权规则特别关注堆数据，因为需要显式管理其生命周期。以下是Rust所有权规则的几个关键点:
  - **每个值都有一个所有者**：Rust中的数据由一个变量所有，这个变量被称为数据的所有者;
  - **一次只能有一个所有者**：在任意时间点，堆上的数据只能由一个变量所拥有;
  - **当所有者超出作用域时，数据将被丢弃**：当拥有堆数据的变量超出作用域时，Rust将自动调用`drop`函数来清理堆上的数据;
- 所有权规则对栈数据也有影响，因为栈上的数据通常较小且生命周期有限，它们通常随着函数调用的结束而自动清理。然而，栈上的数据可以包含对堆数据的引用，这时所有权规则就会发挥作用，确保在栈上的引用有效时，堆上的数据不会被意外清理;
- Rust的所有权系统是它安全内存管理的关键特征之一，它通过在编译时检查所有权规则来防止诸如空悬指针、内存泄漏和并发访问冲突等问题。这些规则使得Rust无需垃圾回收机制即可管理内存，从而提供了高性能和安全性;


## 栈内存 vs 堆内存
- 在像 Rust 这样的系统级编程语言里，一个值是在 stack 上还是在 heap 上对语言的行为和你为什么要做某些決定是有更大的影响的;
- 在你的代码运行的时候，Stack 和 Heap 都是你可用的内存，但他们的结构很不相同;
- Stack 按值的接收顺序来存储，按相反的顺序将它们移除(后进先出，LFO):
  - 添加数据叫做压入栈;
  - 移除数据叫做弹出栈;
- 所有存储在 Stack 上的数据必须拥有己知的固定的大小;
  - 编译时大小未知的数据或运行时大小可能发生变化的数据必须存放在 heap 上;
- Heap 内存组织性差一些:
  - 当你把数据放入 heap 时，你会请求一定数量的空间;
  - 操作系统在 heap 里找到一块足够大的空间，把它标记为在用，并返回一个指针，也就是这个空间的地址;
  - 这个过程叫做在 heap 上进行分配，有时仅仅称为 `分配`;
- 把值压到 stack 上不叫分配;
- 因为指针是已知固定大小的，可以把指针存放在 stack 上;
  - 但如果想要实际数据，你必须使用指针来定;
- 把数据压到 stack 上要比在 heap 上分配快得多;
  - 因为操作系统不需要寻找用来存储新数据的空间，那个位置永远都在 stack 的顶端;
- 在heap 上分配空间需要做更多的工作:
  - 操作系统首先需要找到一个足够大的空间来存放数据，然后要做好记录方便下次分配;


## 访问数据
- 访问 heap 中的数据要比访问 stack 中的数据慢，因为需要通过指针才能找到 heap 中的数据;
  - 对于现代的处理器来说，由于缓存的缘故，如果指令在内存中跳转的次数越少，那么速度就越快;
- 如果数据存放的距离比较近，那么处理器的处理速度就会更快一些（stack 上）;
- 如果数据之间的距离比较远，那么处理速度就会慢一些 （heap 上）;
  - 在 heap 上分配大量的空间也是需要时间的;


## 函数调用
- 当你的代码调用函数时，值被传入到函数（也包括指向 heap 的指针）。函数本地的变量被压到 stack 上。当函数结束后，这些值会从 stack 上弹出;


## 所有权存在的原因
- 所有权解决的问题:
  - 跟踪代码的哪些部分正在使用 heap 的哪些数据;
  - 最小化 heap 上的重复数据量;
  - 清理 heap 上未使用的数据以避免空间不足;
- 一旦你懂的了所有权，那么就不需要经常去想 stack 或 heap 了;
- 但是知道管理 heap 数据是所有权存在的原因，这有助于解释它为什么会这样工作;

