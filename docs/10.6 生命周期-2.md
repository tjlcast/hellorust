
[TOC]

## 生命周期标注语法
- 生命周期的标注不会改变引用的生命周期长度
- 当指定了泛型生命周期参数，函数可以接收带有任何生命周期的引用
- 生命周期的标注：描述了多个引用的生命周期间的关系，但不影响生命周期


## 生命周期标注一语法
- 生命周期参数名：
  - 以 **'** 开头
  - 通常全小写且非常短
  - 很多人使用 **'a**

- 生命周期标注的位置：
  - 在引用的＆符号后
  - 使用空格将标注和引用类型分开

## 生命周期标注一例子
- &i32 //一个引用
- &'a i32 //一个带有生命周期标注的引用
- &'a mut i32 //一个带有生命周期标注的可变引用
- 单个生命周期标注本身没有意义


## 函数签名中的生命周期标注
- 泛型生命周期参数声明在：**函数名**和**参数列表**之间的`<>`里
- 生命周期 **'a** 的实际生命周期是：×和y两个生命周期中较小的那个
- ```rust
    fn main() {
        let string1 = String::from("abcd");
        let result;
        {
            let string2 = String::from("xyz");
            result = longest(string1.as_str(), string2.as_str());
        }
        println!("The longest string is {}", result);
    }

    fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
      if x.len() > y.len() {
          x
      } else {
          y
      }
    }
  ```
  - 这段代码会异常，这里的参数列表的生命周期使用其中的最小生命周期，也是就是 **string2** 的生命周期，返回值也使用该生命周期，故会发生panic.
